using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Maui.Trading.Indicators;
using Maui.Trading.Model;
using Maui.Trading.Binding;
using Maui.Trading.Binding.Decorators;
using Maui.Entities;

namespace Maui.Trading.Reporting
{
    // Decission: we are going to really merge "charts" here - as the name states. that means we do not 
    // take the raw data from the raw data sections (e.g. IndicatorPointsSection) but we are taking the
    // charts as generated by the indicator. if an indicator does not generate a chart - we will not 
    // merge anything. if this is not the desired behaviour for s.o. a new merge operator has to be written
    public class PriceBasedIndicatorChartMergeOperator : IChartMergeOperator
    {
        public PriceBasedIndicatorChartMergeOperator( string name, IEnumerable<string> indicators )
        {
            Name = name;
            Indicators = indicators.ToList();
        }

        public string Name
        {
            get;
            private set;
        }

        public IEnumerable<string> Indicators
        {
            get;
            private set;
        }

        [DataSource]
        public IPriceSeriesDataSource Prices
        {
            get;
            set;
        }

        public bool MergeSignals
        {
            get;
            set;
        }

        public ICombinedSignalCreator CombinedSignalCreator
        {
            get;
            set;
        }

        public bool HandledByMergeOperator( IChartSection chartSection )
        {
            return Indicators.Contains( chartSection.Name );
        }

        public AbstractSection Merge( IAnalysisResult result )
        {
            var visitor = new GenericChartSectionVisitor( Indicators );
            var walker = new ReportWalker( visitor );
            walker.Visit( result.Report );

            if ( !visitor.Sections.Any() )
            {
                return null;
            }

            var section = CreateMergedChartsSection( result.Stock, visitor.Sections );
            return section;
        }

        private AbstractSection CreateMergedChartsSection( StockHandle stock, IEnumerable<GenericChartSection> sections )
        {
            var chart = new StockPriceChart( stock, Prices.ForStock( stock ) );

            AddIndicatorPoints( chart, sections );
            AddSignals( chart, sections );

            return new GenericChartSection( Name, chart );
        }

        private void AddIndicatorPoints( StockPriceChart chart, IEnumerable<GenericChartSection> sections )
        {
            foreach ( var section in sections )
            {
                foreach ( var entry in section.Chart.IndicatorPoints )
                {
                    // could be that the chart is already added
                    // sample: indicator 1 = SMA.200, indicator 2 = SMA.10xSMA.200 (double cross over). then SMA.200 would be added two times
                    if ( !chart.IndicatorPoints.ContainsKey( entry.Key ) )
                    {
                        chart.IndicatorPoints.Add( entry.Key, entry.Value );
                    }
                }
            }
        }

        private void AddSignals( StockPriceChart chart, IEnumerable<GenericChartSection> sections )
        {
            if ( !MergeSignals )
            {
                return;
            }

            var signals = sections
                .Select( section => section.Chart.Signals )
                .Where( s => s != null )
                .ToList();

            if ( !signals.Any() )
            {
                return;
            }

            if ( CombinedSignalCreator == null )
            {
                throw new ArgumentNullException( "CombinedSignalCreator not set" );
            }

            chart.Signals = CombinedSignalCreator.Create( signals );
        }

        private class GenericChartSectionVisitor : IReportVisitor
        {
            private IEnumerable<string> myIndicators;

            public GenericChartSectionVisitor( IEnumerable<string> indicators )
            {
                myIndicators = indicators;

                Sections = new List<GenericChartSection>();
            }

            public List<GenericChartSection> Sections
            {
                get;
                private set;
            }

            public void Visit( Report report )
            {
                // nothing to do
            }

            public void Visit( AbstractSection section )
            {
                if ( !typeof( GenericChartSection ).IsAssignableFrom( section.GetType() ) )
                {
                    return;
                }

                if ( !myIndicators.Contains( section.Name ) )
                {
                    return;
                }

                Sections.Add( (GenericChartSection)section );
            }
        }
    }
}
